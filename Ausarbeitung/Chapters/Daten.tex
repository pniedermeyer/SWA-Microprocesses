
\chapter{Daten}\label{ch:Daten}

Die Daten eines Systems, das eine Microservice-Architektur nutzt sind sehr stark verteilt. Dies hat den Grund, das jeder Microservice eine eigene Datenbank besitzt. Würde, wie bei einem Monolithen, alle Daten in einer einzigen Datenbank gespeichert werden, dann würde die Skalierbarkeit sehr stark darunter leiden. Schließlich war einer der Gründe für Microservices, dass jeder der Microservices auf einem eigenen Server laufen könnte, um das System skalieren zu können. Würden alle Daten in einer einzigen Datenbank gespeichert werden (die nur auf einem einzigen Server läuft), würde hier erneut ein Flaschenhals entstehen, da dieser Datenbank-Server nicht im selben Ausmaß skalieren kann, wie es die Microservices können.

Eins der größten Probleme mit den Daten bei einem Microservice-System ist, das durch die Verteilung der Daten keine Transaktionen mehr möglich sind sondern die Änderungen an den Daten anderen Microservices mitgeteilt werden müssen (beispielsweise muss das Anlegen eines Nutzers an andere Microservices mitgeteilt werden).

\section{Synchrone Persistenz}

Synchrone Persistenz ist ein Ansatz um das oben genannte Problem der Synchronisierung zu Lösen. Bei der Synchronen Persistenz wird jede Änderung an den Daten direkt an alle anderen Microservice, die von diesen Daten abhängen, weitergegeben. Wenn beispielsweise ein Microservice B von den Daten des Microservice A abhängt, dann würde B einen Endpunkt besitzen, den A aufruft, sobald sich Daten ändern. A wartet dann auf die Antwort von B, um sicherzustellen, dass die Daten auch tatsächlich in B aktualisiert wurden. Wenn mehrere Microservices von den Daten abhängen, dann muss jeder dieser abhängenden Services einzeln Benachrichtigt werden. Es muss beachtet werden, dass Transaktionen (nach ACID-Prinzip) dennoch nicht möglich sind. Beispielsweise sind Rollbacks nur schwer umsetzbar wenn fünf Microservices Benachrichtigt werden, dies aber nach dem dritten scheitert (es müsste also ein Rollback bei den ersten beiden durchgeführt werden). Desweiteren existieren die folgenden Probleme:

\paragraph{Hohe Kupplung}
Bei der Synchronen Persistenz existiert eine 1:N Beziehung zwischen den Microservices. Das bedeutet, dass im schlechtesten Fall (wenn jeder Microservice immer jeden anderen Microservice benachrichtigen muss) $\dfrac{n(n-1)}{2}$
Beziehungen existieren. Zudem steigt offensichtlich deren Anzahl sehr stark, wenn neue Microservices zum System hinzugefügt werden. Dies erhöht die Komplexität des Systems enorm und macht es für Entwickler sehr schwer, den Überblick zu behalten.

\paragraph{Service-Ausfälle}
Wenn ein einzelner Microservice ausfällt kann dieser nicht mehr Benachrichtigt werden. Hierdurch müsste entweder jeder Microservice speichern, welche Microservices noch Benachrichtigt werden muss (wobei die logik hierfür sehr komplex ist, und den Rahmen eines einzelnen Microservices sprengt), oder der gesamte Befehl scheitert, wodurch allerdings ein Rollback ausgeführt werden müsste, was, wie bereits weiter oben beschrieben, problematisch ist. Zudem würde hierdurch das gesamte System deutlich anfälliger gegenüber Ausfällen werden, da in einem Benachrichtigungs-Baum (d.h. ein Microservice Benachrichtigt andere Microservices, die wiederum andere Microservices benachrichtigen etc.) ein einziger Ausfall eines Microservices den gesamten Baum zum Ausfallen bringt.

\paragraph{Netzwerk-Overhead}
Synchrone Persistenz ist nicht sehr performant, da immer gewartet wird, bis die benachrichtigen Services eine Antwort liefern (da sonst Fehlerbehandlung sehr schwierig wird, da nicht bekannt ist, ob die Services auch tatsächlich benachrichtigt wurden). Wenn hier allerdings ein Baum mit mehreren Ebenen existiert, dann muss der Wurzel-Service warten, bis alle Blatt Services geantwortet haben. Dies kann, je nach Netzwerk-Verbindung oder der Komplexität der Berechnungen bei einer Benachrichtigung, sehr lange dauern.

\section{Ereignis gesteuerte asynchrone Persistenz}

Ereignis gesteuerte asynchrone Persistenz (im folgenden nurnoch Event-Persistenz genannt) ist eine alternative zur Synchronen Persistenz. Der Name beschreibt das Prinzip bereits sehr gut. Es wird ein Ereignis-Basiertes System eingesetzt und, im Gegensatz zur synchronen Persistenz, werden Änderungen nicht sofort, sondern asynchron übernommen. Das bedeutet, dass ein benachrichtigender Microservice nicht auf die Antwort aller benachrichtigten Microservices warten muss, sondern diese möglicherweise erst zu einem späteren Zeitpunkt benachrichtigt werden (hierbei handelt es sich allerdings in der Regel um kleine Zeitverzägerungen, die nicht von einem Menschen bemerkbar ist).
Der Ablauf bei der Event-Persistenz zum Benachrichtigen von anderen Microservices läuft ab, indem der benachrichtigende Microservice, auf einem bestimmten Kanal den Event-Manager benachrichtig, dass es neue Daten gibt. Hierbei existiert ein Kanal, jeweils einer pro möglicher Veränderung (beispielsweise gibt es einen Kanal für das Erstellen und einen Kanal für das Löschen eines Nutzers). Andere Microservices, die benachrichtigt werden müssen, tragen sich beim Event-Manager für einen bestimmten Kanal ein und werden dann automatisch von diesem benachrichtigt, wenn ein neues Event in dem jeweiligen Kanal ausgelöst wurde.
Hierdurch wird die hohe Kupplung der Synchronen Persistenz verhindert, da jeder Microservice immer nur direkt mit dem Event-Manager kommuniziert und nicht von anderen Microservices abhängig ist. Zudem merkt der Event-Manager welche Services bereits benachrichtigt wurden und welche nicht. Wenn also ein einziger Service ausfällt (und demnach nicht benachrichtigt werden konnte), wird dieser lediglich erst später benachrichtigt. Hierdurch bringt ein einziger Ausfall nicht das gesamte System zum Einsturz, wie es bei der Synchronen Persistenz der Fall wäre. Wenn ein Service ausfällt, dann verzögert sich lediglich der Zeitpunkt bei dem der jeweilige Microservice die Datenänderung übernimmt, bis der Service wieder funktionsfähig ist (solche Verzögerungen sind aber ohnehin von vornherein ein Teil des Systems, da es asynchron ist).
Ein großes Problem der Event-Persistenz ist allerdings, dass ein Ausfall des Event-Managers das gesamte System zum erliegen bringt, da dann keine Benachrichtigungen mehr gesendet werden können. Hier muss also dafür gesorgt werden, dass die Ausfallrate des Event-Managers möglichst gering ist. 
Zudem sind Transaktionen, aus den gleichen Gründen wie bereits bei der Synchronen Persistenz, nach wie vor nicht möglich.\cite{eventual_persitence}

\section{2-Phase-Commit}
Das 2-Phase-Commit (2PC) Protokoll ist ein Protokoll, das Transaktionen in einem Verteilten System ausführen kann. Es hat allerdings einige Probleme. Zum einen nutzt es einen Zentralen Manager, der die Transaktionen orchestriert\footnote{Wobei dieses Problem bei der Event-Persistenz ebenfalls existiert.}. Zum anderen ist das Protokoll sehr aufwändig, und hat die Laufzeit $O(n^2)$. Die Geschwindigkeit wird zudem weiterhin von Sperren auf Ressourcen eingeschränkt. Generell wird 2PC nicht bei Microservices verwendet.

\section{Saga}
Sagas\footnote{Saga ist keine Abkürzung, sondern schlicht das normale Wort \glqq Saga\grqq.} sind eine Möglichkeit, mit der sichergestellt werden kann, dass Daten aktualisiert werden, und mit der, bei einem Fehler, diese Änderungen wieder Rückgängig gemacht werden.
Das Prinzip von Sagas ist das folgende:
Jeder Microservice hat für jedes Datum, dass er aktualisieren kann, jeweils eine Funktion $T$ und $C$ (Transaction beziehungsweise Correction). $T$ aktualisiert ein bestimmtes Datum in der lokalen Datenbank des Services. $C$ macht das genaue Gegenteil, indem es eine Aktualisierung rückgängig macht. Für jedes zu aktualisierende Datum existiert eine Saga, die eine Liste von Microservices darstellt. Zum Aktualisieren eines Datums führt der erste Microservice in der Saga seine $T$-Funktion aus. Dannach wird der zweite Service benachrichtigt, der wiederrum seine $T$-Funktion ausführt. Dies wird solange fortgeführt, bis alle Services in der Saga abgearbeitet wurden. Falls während der Durchführung einer $T$-Funktion ein Fehler auftritt kommt die $C$-Funktion zum tragen. Denn anstatt, dass der nächste Service in der Sage benachrichtigt wird, wird der vorangehende benachrichtigt. Dieser wird dann seinen vorangegangenen aufrufen, der dann die $C$-Funktion aufruft und die erneut die gleiche Nachricht an seinen Vorgänger weitergibt. Hierdurch werden sämtliche Daten, die bis zu diesem Zeitpunkt aktualisiert wurden, wieder durch die $C$-Funktionen rückgängig gemacht.
Sagas nutzen ebenfalls einen Event-Manager, um die Benachrichtigungen zwischen den Services in einer Saga zu verwalten. Hierdurch wird das gesamte System asynchron, und Ausfälle einzelner System sind weniger schwerwiegend.
Die Reihenfolge, in der die Microservices in einer Saga auftreten, muss spezifisch für jede Saga festgelegt werden, hier gibt es keine einheitliche Regel.
Ein Nachteil von Sagas ist, dass sie nicht so lose gekuppelt sind wie es bei der Event-Persistenz der Fall ist. Schließlich müssen bei einer Saga immer alle Services, die Teil dieser Saga sind, gespeichert werden. Vor allem müssen diese im vornherein gut geplant sein, um festzulegen, wie die Reihenfolge der Services innerhalb der Saga auszusehen haben.\cite{sagas}
