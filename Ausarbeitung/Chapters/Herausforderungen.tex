\chapter{Herausforderungen}\label{ch:Herausforderungen}

In dem folgendem Kapitel werden die Herausforderungen und Schwierigkeiten von Miroservices beschrieben. Dabei werden die Anforderungen an das Netzwerk beschrieben, welches mit den Lasten von Verteilten Systemen zurecht kommen muss (\ref{ch:netzwerk}). Darauf folgend wird auf die vermutlich größte Herausforderung eingegangen, der Architektur. Eine schlechte Architektur kann den Vorteil von Microservices zunichte machen und muss daher fortlaufend angepasst werden (\ref{ch:Architektur}). Danach wird die benötigt Infrastruktur beschrieben, die bei Microservices um ein vielfaches größer ist und mehr Aufmerksamkeit bedarf als bei einer mololithischen Entwicklung (\ref{ch:Infrastruktur}).

\section{Netzwerk} \label{ch:netzwerk}

Da Microservices verteilte Systeme sind, werden Aufrufe untereinander über das Netzwerk verschickt. Damit verbunden sind Latenz und Antwortzeiten die mit steigender Netzwerkauslastung exponentiell steigen.\todo {Bild ändern} \newline
\begin{figure}[bth] 
	\centering
	\includegraphics[width=0.7\textwidth]{Graphics/Latenz}
	\caption{Latenz bei einem Netzwerkaufruf}
	\label{fig:Latenz}
\end{figure}

In Fig. \ref{fig:Latenz} ist ein typischer Aufruf über ein Netzwerk zu sehen. Während die Anfrage über das Netzwerk verschickt, von einem anderen Service bearbeitet und die Antwort wieder zurück geschickt wird muss der ursprüngliche Service warten. Selbst wenn die Latenz einer Nachricht nur 0,5 ms beträgt, könnte ein Prozessor mit 3 GHz in dieser Zeit ~1,5 Millionen Operationen durchführen. Daher sollte auf die Entfernung der einzelnen Services geachtet werden und diese so nah wie möglich beieinander zu halten. Auch sollte darauf geachtet werden, dass das Netzwerk nicht überlastet wird. Subnetze bieten sich bei dieser Problemstellung an. \paragraph{}
Eine hohe Kommunikation zwischen Microservices spricht jedoch auch für eine schlechte Skalierung der Services und für zu vielen Abhängigkeiten. Solche Abhängigkeiten sollen jedoch vermeiden werden, da dadurch der Vorteil von Microservices verloren geht - das unabhängige Deployment. Mehr zum Thema Architektur im folgendem Unterkapitel (\ref{ch:Architektur}). \paragraph{}
Ein weiteres Problem welches bei verteilten Systemen auftreten kann, ist der Ausfall eines Teilsystems. Wenn dies geschieht, müssen unterschiedliche Maßnahmen getroffen werden, damit nicht das gesamte System zum Erliegen kommt. So muss es Pläne geben, was passiert, wenn eine Request keine Antwort bekommt. Dafür kann es verschiedene Gründe geben. Es kann beispielsweise daran liegen, dass die Nachricht im Netzwerk nicht richtig weitergeleitet wurde. Eine weitere wahrscheinliche Möglichkeit ist ein abgestürzter Gegenspieler. Im ersten Fall kann durch eine erneut gesendete Anfrage das Problem gelöst werden, im zweiten Fall würde dies jedoch ohne weiteren Maßnahmen zu einer Endlosschleife führen. Dies gilt es zu erkennen und geeignete Fehlerfälle mitzubeachten. \newline
Währenddessen muss der abgestürzte Microservice neu gestartet werden, am Besten wäre es, wenn mehrere Instanzen des Services aktiv wären und im Falle eines Absturzes diese kurzzeitig die zusätzlichen Anfragen bearbeiten könnten. Gleichzeitig wird im Hintergrund der Service automatisch neu gestartet und kann danach weiterarbeiten. \newline
Im Falle von großen Lastwechseln kann dieser Mechanismus auch dazu genutzt werden bei Bedarf neue Instanzen eines Services zu starten, damit keine zu großen Warteschlangen entstehen und die Antwortzeiten gering bleiben. Ein Aufteilen der Requests auf die einzelnen Instanzen kann dabei dann mittels Service Discovery und Load Balancing geschehen.

\section{Architektur} \label{ch:Architektur}
Bei Microservices ist es wichtig, dass die fachliche Struktur mit der Organisationsstruktur übereinstimmt (Gesetz von Conway). Die unterschiedlichen fachlichen Funktionen werden dabei in Microservices aufgeteilt. Ein Team der Organisation ist dabei für einen oder mehrere Microservices zuständig. Die Microservices anderer Teams werden dagegen als Black-Box gesehen, von denen nur die Schnittstelle bekannt ist. Daher können die Microservices auch in unterschiedlichen Technologien implementiert sein. Die einzige Gemeinsamkeit, die alle Services haben müssen, ist eine einheitliche Schnittstelle. Eine valide Option hierfür wäre eine REST Schnittstelle. \newline
Durch die verschiedenen Technologien ist es schwer einen Gesamtüberblick über das System zu behalten. Falls dies jedoch benötigt wird, ist es ratsam einen Technologiestack vorzuschreiben. Dies kann auch partiell durchgeführt werden, falls beispielsweise einheitlich geloggt werden soll. \paragraph{Änderungen}
Durch die Aufteilung in kleine Microservices sind Änderungen und Refactorings innerhalb eines Microservices sehr leicht umzusetzen. Bei größeren Änderungen oder Fehlern ist es auch leicht den gesamten Microservice zu ersetzen und neu zu implementieren. \newline
Falls neue Anforderungen Änderungen an mehreren Microservices erfordern, ist dies sehr viel mehr Arbeit. Kommt dies öfters vor, kann dies auch für eine schlechte Architektur sprechen, die überarbeitet werden sollte. Bei Microservice-übergreifenden Änderungen bei denen mehrere Teams beteiligt sind, müssen diese koordiniert werden und sich miteinander abstimmen. Auch können die Services in unterschiedlichen Technologien entwickelt worden sein oder Bibliotheken in unterschiedlichen Versionen nutzen. Dies alles macht den Vorteil von Microservices zunichte und ist sehr Aufwändig. Daher ist das initiale Erstellen der Architektur ein essentieller Punkt, der über den Erfolg des Projektes maßgeblich mitentscheidet.

\paragraph{Anpassen der Architektur} Wie bereits gezeigt, ist die Architektur ein essentieller Part eines Microservice Systems. Durch eine gute Architektur können Anforderungen nachhaltig schnell umgesetzt werden (Micorservice-intern) und es können die Technologien genutzt werden, die für den Anwendungsfall optimal sind. \newline
Jedoch ändert sich die optimale Architektur mit neuen Anforderungen. Wenn die Architektur daraufhin (agil) angepasst wird, ergibt sich daraus auch kein Problem, jedoch wenn man an der alten Architektur festhält. \newline
Gründe für eine Anpassung der Architektur können folgende sein: \begin{itemize}
	\item Ein Microservice ist zu groß und muss aufgeteilt werden. Zeichen hierfür ist beispielsweise eine schlechte Verständlichkeit oder auch eine Größe, mit der nicht einmal ein ganzes Team zurecht kommt. Ebenfalls kann es vorkommen dass ein Micorservice mehrere Themengebiete umfasst.
	\item Ein Microservice bearbeitet Funktionen, die in einem anderen Microservice besser aufgehoben wären. Erkennbar sind solche Funktionen durch viel Kommunikation zwischen den beiden Services. Ebenfalls können Bereiche in einem Microservice sehr wenig miteinander zu tun haben. Diese können dann aus Gründen der Übersichtlichkeit in neue Microservices getrennt werden.
	\item Wenn eine Funktion von mehreren Microservices genutzt werden soll, sollte eine Architekturänderung ebenfalls in Betracht gezogen werden.
\end{itemize}
Um diese Probleme zu lösen gibt es verschiedene Lösungsansätze: \begin{description}
	\item [Gemeinsame Bibliotheken] Wenn Code gemeinsam genutzt werden soll, so kann dieser in Bibliotheken ausgelagert werden. Dies setzt voraus, dass die darauf zugreifenden Microservices in der selben Technologie entwickelt werden. \newline
	Dies bedeutet jedoch auch, dass die Microservices von einander abhängig werden und die Arbeit an der Bibliothek koordiniert werden muss. \newline
	Durch 3rd. Party Bibliotheken können so ebenfalls Probleme entstehen. So kann in manchen Laufzeitumgebungen jeweils nur eine Version einer Bibliothek genutzt werden. Das heißt, dass wenn in der neuen Bibliothek die externe Bibliothek XY v2.0 benötigt wird, muss der Code des Microservices, wenn er die Bibliothek XY benötigt, diese ebenfalls in der Version 2.0 nutzen. \newline
	Wegen diesen Problemen wird eine Wiederverwendung von Code in Microservices nicht forciert.
	\item [Code übertragen] Ein anderer Weg eine Funktion in einem Microservice verfügbar zu machen, ist die Codeübertragung. Der Ansatz ist wie bei einer gemeinsamen Bibliothek, nur dass keine Abhängigkeiten entstehen. Dadurch kann eine lose Kopplung zwischen zwei Abhängigen und stark kommunizierenden Microservices wiederhergestellt werden. Dabei spielt es keine Rolle ob der Code im ursprünglichem Microservice bestehen bleibt oder nicht, wodurch jedoch Redundanzen entstehen. Dies bedeutet dass Bug Fixes an mehreren Stellen vorgenommen werden müssen, dagegen können sich die Microservices/Funktionen unabhängig voneinander in unterschiedliche Richtungen weiterentwickeln. \newline
	Es muss darauf geachtet werden, dass durch das Hinzufügen von Funktionen der Microservice nicht zu groß wird und zu einem Monolithen mutiert.
	\item[Gemeinsamer Service] Anstatt den Code in eine Bibliothek auszulagern, kann dieser auch in einen neuen Microservice überführt werden. Dadurch werden auch verschiedenen Technologien unterstützt. Mit dieser Methode werden die Micorservices auch klein gehalten, was vorteilhaft für die Übersichtlichkeit und Verständlichkeit des Systems ist. Diese neuen Microservices sind dann reine Backend-Services, da diese keine Benutzeroberfläche besitzen. \newline
	Dieses Verfahren kann auch gut dazu genutzt werden wenn ein Microservice zu groß wird. Durch Auslagern von Funktionen kann die Wartbarkeit wieder erhöht werden.
	\item[Neu schreiben] Mit der Zeit kann es vorkommen dass ein Microservice schwer wartbar wird. Dies kann beispielsweise durch einen ''historisch gewachsenen'' Code geschehen, oder auch durch die Auswahl einer nicht praktikablen Technologie. Gerade bei solchen Problemen haben Microservices ihren Vorteil. \newline
	Durch ihre kleine Größe kann der gesamte Service ohne größeren Aufwand neu entwickelt werden. Dabei können neue Erkenntnisse über die Domäne direkt in die Neuimplementierung einfließen. Ein Wechseln der Technologie ist ebenfalls kein Problem, solang die Schnittstellen gleich bleiben.
\end{description}

\section{Infrastruktur} \label{ch:Infrastruktur}
 Auch bei der Infrastruktur gibt es bei Microservices Hürden und Herausforderungen. So werden viel mehr Server oder Virtuelle Maschinen benötigt als bei einem Monolithen. Die verschiedenen Services müssen aufgrund ihrer Unabhängigkeit auf einzelnen Servern/VM's liegen. Dies kann bspw. an verschiedenen Versionen von Bibliotheken liegen oder auch an dem unabhängigen Deployment der Services. \newline 
Einer der großen Vorteile von Micorservices ist das lastabhängige Starten zusätzlicher Instanzen. Dies muss automatisch und auf einer neuen VM geschehen. Um jedoch überhaupt erstmal festzustellen, wie groß die Last ist, muss ein geeignetes Monitoring auf allen Services aktiv sein. Aufgrund der verschiedenen Technologien kann dies zu einem großen Problem werden. \newline
Ebenfalls sollte ein Monitoring für die Problemfindung vorhanden sein. Dies muss auf die einzelnen Services angepasst sein, damit Schwachstellen erkannt und optimiert werden können. \newline
Auch bei der Entwicklung gibt es im Vergleich zu einem Monolithen Nachteile. So muss für jeden einzelnen Microservice eine Versionskontrolle eingerichtet werden. Eine Build Pipeline pro Micorservice ist ebenfalls empfehlenswert. Diese Entwicklungsanforderungen bedeuten für das Unternehmen zusätzliche Infrastruktur wie auch erhöhte Administration.







